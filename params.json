{
  "name": "Libni",
  "tagline": "Open library and examples for building and receiving commands networked input devices",
  "body": "# libni\r\nLibrary for Network Input\r\n=========================\r\n\r\nOpen library and examples for building and receiving commands\r\nfrom networked input devices.\r\n\r\nIn a Libni setup there are usually two type of devices:\r\n\r\n1. Controllers: the devices which send network updates. Controllers usually have buttons and/or some \r\n   analog sensors (sliders, turn knobs, gyroscopes). These could also be\r\n   modern, unsought of input devices to augment your VR or AR experience, like addons\r\n   for your Oculus Rift or Google Cardboard.\r\n\r\n2. Receivers: these devices receive the inputs from the controllers and\r\n   act depending on them. These could be games with the libni receiver library,\r\n   a drone or other remote controlled vehicle, or the nii (Network Input Injector),\r\n   turning the received signals into keystrokes and mouse events.\r\n\r\nLibni enabled controllers send about every 10-20ms packages with update on all sensors it\r\nis responsible for. Therefore it can easily use UDP as some loss in\r\ndata is covered with the next package.\r\n\r\nThe package has two formats, signalled in its header (the header is constant):\r\n\r\nHeader:\r\n- Byte 0-3: always \"LBNI\" - a magic header\r\n- Byte 4-5: The protocol version, so far always 1 (in two bytes: 0, 1)\r\n- Byte 6-7: Protocol Type: either 0 or 1 (there are these types:0 is a\r\nbitblock, 1 is a number of controls + their values, description below)\r\n- Byte 8-11: UID, uniuque id, just chose 4 random bytes\r\n- Byte 12-15: a specific client id to distiguish diffrent controllers,\r\nbut have fixed ids\r\n\r\nThese 15 bytes are followed by the controller data.\r\n\r\nIf the protocol type is 0, the data looks like the following:\r\n- 32 bytes (256bits): status of 256 buttons (bit=0 means unpressed, 1\r\nmeans pressed). In byte 0 are buttons 0-7, in byte 1 buttons 6-15, ...\r\nBasically if only button 0 is pressed the first byte is 1.\r\n- 32 bytes with 2-byte analog values, meaning 16 values. The values\r\nare from -32768 to 32767, thefore ie 255,255 means -1.\r\n\r\nIf the protocol type is 1, it is a slightly simpler but less compressed format:\r\nIt follows a list of events.\r\n\r\nAn Event starts with its type and is followed by a load of different\r\nlength depending on the type:\r\n- type: 0    - no load\r\n- type: 1    - load: 1 byte with button number\r\n- type: 2    - load: 1 byte with button number\r\n- type: 3    - load: 1 byte with analog number + 2 byte big endian value\r\n- type: 4    - load: 2 byte with big endian analog number + 4 byte big endian value or 32 big endian\r\n  floating point\r\n- type: 5    - load: 4 byte id + 16 byte data\r\n\r\nYou can send the packages via udp, tcp, or mqtt (tcp does not yet work\r\nin all projects).\r\n\r\nThis is the current structure of the libni-project:\r\n\r\n    /controller - examples for libni controllers (esp, libgdx, ...)\r\n      /bash - a small socat script to just send udp-data somewhere\r\n      /esp8266 - examples for esp8266 (including my touch library)\r\n      /libgdx - a small virtual joystick for desktop or mobile phone\r\n    simulating a joystick and a fire button\r\n      /python - a test desktop client similar to the libgdx client\r\n    \r\n    /receiver - example for receivers\r\n      /java - libgdx receiver library and nii - java network input injector\r\n      /python - skeleton for a potential receiver in python\r\n      /shell - a small socat script to just dump the udp-data on the screen\r\n    \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}